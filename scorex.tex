\documentclass[]{report}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}


\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}


% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
%\newtheorem{lemma}{Lemma}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
%\newtheorem{definition}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\btc}{\includegraphics[height=8pt]{assets/btc.jpg}}

\begin{document}

%\lstset{language=Scala}
%\begin{lstlisting}[style=myScalastyle]
%

\title{Scorex Tutorial}
\author{Alexander Chepurnoy}
\author{Amitabh Saxena}
\date{June-August, 2016}
\maketitle

% \begin{abstract}  


\chapter{Executive Summary}

This paper describes the Scorex project and how it can be used to create blockchain protocols such as cryptocurrencies (Bitcoin). Scorex is a library written in Scala with loosely coupled components that can be used as the underlying framework for making applications using a blockchain (a type of decentralized consensus-based protocol). 
The intended audience is developers wanting to create or experiment with such applications. Some basic knowledge of cryptography, data structures and cryptocurrencies is required. Some programming background is also required to understand the code-snippets. For good explanation of cryptography primitives and protocols please refer to the foundational book of~\cite{katz2014introduction}. 

In order to understand Scorex, it is helpful to consider Bitcoin, Namecoin and Nxt as three distinct applications of blockchain. Scorex gives the underlying framework for developing any of the three apps (and several others) by writing a thin layer of code. 


\section{Organization}


This document is organized as follows. In Chapter~\ref{building-blocks}, we describe basic building blocks of a blockchain system. In Chapter~\ref{impl}, we describe how the blocks are implemented in the Scorex framework. We provide code snippets in Scala language. No prior knowledge of the Scala language is required.


\chapter{Introduction}

If you have heard of blockchain then you have indirectly heard of Bitcoin, the decentralized peer-to-peer currency network with some fancy features such as the ability to transfer real value over virtual channels. This is because Bitcoin is the first widespread use of the blockchain, which is essentially a {\em decentralized tamper-resistant append-only database} of transactions (sometimes also referred to as a {\em ledger}). Let us elaborate on this in more detail in the following sections. 

\section{Blockchain and Boxes}


Define $F$ to be the set of mappings $\mathbb{Z}\times\mathbb{Z}^{+} \mapsto \{-1, 0, 1\}$ over the integers. 
Each pair represents a `box' of type ((public-key, coinID), amount)\footnote{Each integer in the left of $\mathbb{Z}\times\mathbb{Z}^{+}$ is assumed to map to a unique pair of type (public-key, coinID), where coinID is some unique identifier for the coins. For now, it is sufficient to consider the left integer as some `ownership identifier' of the amount on the right.}. 

Each element from $F$ maps the pairs of such integers (i.e., all boxes) to one of three states: $-1, 0, 1$, indicating that the corresponding box is respectively {\em Unused} (never used), {\em Closed} (contains funds) and {\em Opened} (funds have been used).
A blockchain is an infinite sequence $f_0, f_1, f_2, \ldots \in F$ of functions from $F$ applied iteratively on $\mathbb{Z}$ such that: % each $f_i$ satisfies the following:
\begin{enumerate}
	\item $f_i \neq f_{i+1}$ (there must be at least one state change in the boxes).
	\item $\forall (x, y) : f_i(x, y) \leq f_{i+1}(x, y)$ (state cannot decrease).
	\item $\forall (x, y) : f_i(x, y)\cdot f_{i+1}(x, y) = 0$ (state cannot increase > 1).
\end{enumerate}

$f_0$ is called the {\em genesis mapping} or {\em genesis state}. Each mapping $f_i$ represents a snapshot of the system at iteration $i$, which indicates the state of each box. 
The set $m_i=\{(x, y)| f_i(x, y) = 0\}$ is called the {\em minimal state} at iteration $i$. 

A {\em block} $b_i$ gives the deltas between two successive states $(f_{i+1}, f_{i})$ and is essentially defines a set of boxes to open and close. Formally, $b_{i}$ is the set $\{(x, y)|f_{i+1}(x, y)\neq f_i(x, y)\}$. The transformation rules ensure that there is a unique block for each iteration. At any iteration $i$, a client needs only the current minimal state $m_i$ and the next block $b_i$ to compute the next minimal state. 
While this is enough to define a generic blockchain, Bitcoin has some additional rules:

\begin{enumerate}
	\item For any block $b_{i}$, $$\sum_{(x, y)\in b_{i}} y\cdot f_{i+1}(x, y) +\sum_{(x, y)\in b_{i}} y\cdot f_{i}(x, y) \leq  r(i),$$ for some {\em reward} function $r$.
	
	Note that $\sum_{(x, y)\in b_{i}} y\cdot f_{i}(x, y)$ is the negative of the sum of amount in all the boxes to be closed in this iteration and $\sum_{(x, y)\in b_{i}} y\cdot f_{i+1}(x, y)$ is the sum for the boxes to be opened. Thus, the LHS is the amount of bitcoins `created' in this block minus the amount bitcoins `destroyed'. The inequality says that the net amount of bitcoins created in a block cannot be more than the reward. 
	\item For each box $(x, y)\in b_i$, there is a {\em transaction} that acts as the {\em witness} of opening or	closing that box. A transaction acts like a proof that a particular state change was authorized via some public key, which will be discussed in detail in the next chapter. 
\end{enumerate}

At any iteration $i$ of the blockchain, older snapshots $(f_0, f_1, f_2, \ldots)$ are considered tamper-resistant while fresh copies ($\ldots, f_{i-2}, f_{i-1}, f_i$) may be susceptible to deletion or tampering, depending on the computational power of the attacker. However, after the snapshot becomes sufficiently old, it can be considered as tamper-proof for all practical purposes. The rules of the protocol ensure that if all honest nodes start with the same initial state $f_0$ and apply the same blocks successively then they will have the same snapshots $f_i$ at any iteration $i$. The task here is to ensure that the blocks are always applied in the right order. This is a consensus problem, and is solved in Bitcoin using a concept called {\em proof-of-work} -- the solution to a hard puzzle. The idea is that not everyone gets to choose which block to apply to reach the next valid snapshot, but only by someone who has invested a large amount of computing power and provides the proof on a first-come-first-serve basis. Snapshots are connected -- each block is linked to the previous one via a cryptographic hash so that if someone else provides a proof-of-work and the network accepts it, then all existing work for ``winning'' this block is invalidated and the contenders have to start again with the newly accepted block as the starting point. To incentivize nodes to expend work, each accepted snapshot comes with some reward in the form of tokens generated (additional states that benefit the node solving the puzzle). 

The rules encoding state changes are hardwired into the peer-to-peer nodes so that once a majority of them are running the code and act honestly, we can be ensured that block updates follow the correct rules. Blockchain can tolerate a high number of corrupt nodes (those controlled by an attacker) -- close to 40\%. 

\paragraph{Transactions:} Transactions can also be seen as state changes authorized via private keys and validated by the corresponding public keys. The transaction can encode information pertaining to funds transfer (as in Bitcoin) or have additional information pertaining to the external world such as attaching a key-value pairs to a public key (as in Namecoin -- a decentralized DNS).
While Bitcoin seems to be the primary use of blockchain right now, other intriguing use cases such as Namecoin have also been presented. The most powerful of being programmable-blockchains. The idea is simple -- while in Bitcoin, the rules encoding the state changes pertain only to spending of funds, nothing prevents us from coming up with more complex rule that can encode some business logic. One such example, already mentioned, is Namecoin, which additionally has rules for reserving doman names and for transferring them. In all cases, the rules will be written in a language that the node understands and accepts (the grammar is hardwired into the node). 

The newer applications of blockchain are all based on how these rules can be written and how expressive the language is. For instance, Ethereum, another blockchain based protocol boasts of a Turing complete language in contrast to the tiny one that Bitcoin provides. The following summarizes the main proposals.

%
\begin{enumerate}
	\item {\em Bitcoin:} Decentralized currency. 
	
		{\em Advantages:} Decentralization of money, easy to store and spend.
		
		{\em Challenges:} Too much storage, wild price fluctuations, too much energy consumed, limited bandwidth of blocks, not suitable for micro-transactions.
	\item {\em Namecoin:} Decentralized DNS (stores {\em key} $\rightarrow$ {\em value} mappings). 

		{\em Advantages:} Decentralization of DNS, difficult to sensor or shut down.
		
		{\em Challenges:} Similar in design to Bitcoin; some similar challenges, low computing power so less attack resistant.
	
	\item {Ethereum:} Smart	contracts.
	
	  {\em Advantages:} Enable trustless computing via decentralization.		
		
		{\em Challenges:} Turing completeness causes complexity, may have security issues -- example DAO attack.
	
\end{enumerate}
%\section{Other Tutorials}
%
%``How the Bitcoin protocol actually works'' tutorial by Michael Nielsen~\cite{nielsen} define problems led to the creation of Bitcoin and how the cryptocurrency solved them. The original Bitcoin whitepaper by Satoshi Nakamoto~\cite{Nakamoto2008} still provides very good description of basic concepts of Bitcoin. Details of Bitcoin technicalities could be found in the ``Mastering Bitcoin'' book~\cite{antonopoulos2014mastering}.
%

\chapter{Overview of Bitcoin}

Although the bitcoin protocol is quite complex, only a few basic concepts are necessary to understand the idea. These are: {\em transaction}, {\em input}, {\em output}, {\em reference}, {\em block} and {\em confirmation}. We describe them below. Firstly note that in bitcoin, funds are exchanged between {\em addresses} which are %SHA256 
hashes of public keys\footnote{We use the terms `address' and `public key' interchangeably. The meaning will be clear from the context.} %Depending on the context, a symbol $A$ could refer to a public key or an address (the meaning will be clear from the usage). 


 
\section{Transaction} Roughly speaking, a transaction consists of a set of \emph{inputs} (source of funds) and \emph{outputs} (destination of funds). %The funds available at the inputs are pooled together and are available for transfer to the outputs. 
%The transaction specifies how much each output must get. 

\paragraph{Example:} 
Suppose Alice is the owner of address $A$ which received $x$ bitcoins in a previous transaction. She wants to send $y \leq x$ bitcoins to Bob's address $B$. %Note that $A$ might have received more bitcoins in other transactions, which could be combined together. For now we will focus only on how these $x$ bitcoins are spent. 
Alice constructs a transaction with $A$ as the input and $B$ as one of the outputs.
She also inserts $ref$, the reference to the previous transaction's output where $A$ received those $x$ bitcoins.
%\footnote{$ref$ is essentially a 32 bit hash of that older transaction along with the index of the output. This is used to prevent double-spending as explained in Section~\ref{v0}.} 
%The protocol requires that 
The entire amount $x$ must be transferred from $A$. %To satisfy this, 
Alice sends $y$ bitcoins to $B$, sets a transaction fee $t$ and sends the remaining amount $z = x-y-t$ to her {\em change address} $C$, which is the other output. % of the transaction. 
The change address is simply any address owned by Alice (possibly $A$). %, which she can use as input in a further transaction. 
The message 

$$\mbox{``{($ref$: remove $\btc x$ from $A$), (put $\btc y$ in $B$), (put $\btc z$ in $C$)}''}$$ is signed under $A$. 
%The above transaction assigns $\btc y$ from Alice's public key $A$ to Bob's public key $B$. 
%For the transaction to be valid, it must hold that $x \geq y+z$. (In general there can be several outputs as long as the sum of outputs is less than or equal to the input.) The transaction additionally has a verification condition which must pass for the funds to unlocked by $B$. Without loss of generality, we assume that the verification condition is ``Any funds leaving $B$ must be signed under $B$.'' More complex conditions can be inserted here. 

\paragraph{Notation:} We will use the following notation:
\begin{itemize}
	\item $X \stackrel{ref}{\rightarrow} x$ is the message ``($ref$: remove $\btc x$ from $X$)''. This is an input.
\item
$X \leftarrow x$ is the message ``put $\btc x$ in $X$''. This is an output.
\item
$\sigma_X(m)$ is signature on message $m$ under public key $X$. %That is, public key $X$ is used to verify the signature.
\end{itemize}
Alice's transaction is then $(m, \sigma_A(m))$, where $m  =  (A\stackrel{ref}{\rea} x, B \lea y, C \lea z)$. 

%\subsection{The Bitcoin Protocol (V0)} 
%\label{v0}
%\paragraph{Bitcoin protocol:} Here we give the bitcoin protocol (with some simplifications). This is Version  0.
 
 
\paragraph{Transactions:} The above scenario had a single input. In reality, 
a bitcoin transaction can have multiple inputs with no particular link between any source-destination pair. The entire transaction is signed under every input public key. The only requirement is that the sum of the funds at the inputs is greater than or equal to the sum of funds at the outputs. Any difference is considered a transaction fee. More formally, define $m$ to be the message
\[
M \defined (A_1\sr{ref_1}{\ra}x_1, A_2\sr{ref_2}{\ra}x_2, \ldots, A_n\sr{ref_n}{\ra}x_n, B_1\la y_1,
B_2\la y_2, \ldots, B_l\la y_l), 
\] 
where: $(A_1, x_1, ref_1), (A_2, x_2, ref_2),\ldots , (A_n, x_n, ref_n)$ are $n$ tuples each consisting of an address $A_i$, amount of funds $x_i$ and a reference to a previous transaction %'s (unspent) output 
where $A_i$ received $x_i$ bitcoins, and $(B_1, y_1), (B_2, y_2),\ldots, (B_l, y_l)$ are $l$ pairs of addresses and amount of funds. 
%\paragraph{Inputs and outputs:} In message $M$ above, define inputs and outputs as follows:
%\[\mbox{Inputs }\defined A_i\sr{ref_i}{\ra} x_i~~~~~~~~(1\leq i \leq n)\] 
%\[\mbox{Outputs }\defined B_i \la y_i~~~~~~~~(1\leq i \leq l)\]
A valid transaction $tx$ is a tuple: 
\begin{equation}\label{tx0}tx\defined (M, \sigma_{A_1}(M), \sigma_{A_2}(M), \ldots, \sigma_{A_n}(M))\end{equation} such that each signature $\sigma_{A_i}(M)$ verifies correctly and the following holds:
\begin{enumerate}
	\item $\sum_{i=1}^{l}y_i \leq \sum_{i=1}^{n}x_i$ 
	\item Each $ref_i$ for $1\leq i\leq n$ was never used in any prior transaction.
\end{enumerate}

The ordering of the signatures in $tx$ is determined from the ordering of messages inside $M$ (which is fixed due to the signatures).
\paragraph{Referencing outputs:} In future, when spending the funds from any of the outputs (say $B_i \la y_i$) of the above transaction, a reference $ref_{B_i\la y_i}$ to that output needs to be provided. %This reference is computed as follows. 
Let $tx$ be the string of Eqn.~\ref{tx0}. Then \[ref_{B_i\la y_i}\defined (Hash(tx), i)\]

%\paragraph{References are unique:} 
Because $ref$ is constructed from the hash of a previous transaction, it is guaranteed that two different transactions are distinct unless the outputs, input and $ref$ are identical (a forbidden scenario). Due to this, it is also guaranteed (with high probability) that the $ref$s generated by using hashes of two different transactions are also different. In fact, this is how bitcoin prevents double spending (see below). A $ref$ can be used in a transaction at most once. Bitcoin clients maintain a list of unused $ref$s to do this check.

\paragraph{Unspent outputs (and double-spends):} An unspent output is essentially an unused reference, one that has never been used in any transaction. The protocol design guarantees that references to two different outputs will be distinct (see above).
Each client maintains a set called `unspent outputs'. Each output of every transaction is added to this set, and removed when is it used as a reference in another transaction. A transaction with a reference not in this list is considered a double spend and is not processed.


\section{Processing Transactions}


A new transaction is valid if all the references are unused. If so, the transaction is accepted as {\em valid} but {\em unconfirmed}, and is relayed on the network. The clients add each such transaction to a pool of unconfirmed transactions. Unconfirmed transactions can be double-spent. Here we describe the validation process in more detail.
Recall that a transaction is equivalent to 
$$tx\defined (M, \sigma_{A_1}(M), \sigma_{A_2}(M), \ldots, \sigma_{A_n}(M)),$$ 
where $M$ is a message with the following semantics:
\[
M \defined (A_1\sr{ref_1}{\ra}x_1, A_2\sr{ref_2}{\ra}x_2, \ldots, A_n\sr{ref_n}{\ra}x_n, B_1\la y_1,
B_2\la y_2, \ldots, B_l\la y_l), 
\] 
each $\sigma_{A_i}(M)$ is a valid signature on $M$ under $A_i$ and the following holds:

\begin{enumerate}
	\item $\sum_{i=1}^{l}y_i \leq \sum_{i=1}^{n}x_i$.
	\item Each $ref_i$ for $1\leq i\leq n$ was never used in any prior transaction.
	%\item Each $\sigma_{A_i}(M)$ is a valid signature on $M$ under $A_i$.
\end{enumerate}

In reality, the inputs $A_1\sr{ref_1}{\ra}x_1$ are represented only using $ref_i$. The values $A_i$ and $x_i$ are obtained from a {\em UTXO database} that every client must maintain.\footnote{The inputs additionally include the public key corresponding to address $A_i$. We can assume that this key is part of the signature.} This database is a key-value store of type $ref_i \ra (A_i, x_i)$. Note that in order to validate transactions and participate in the protocol, maintaining this UTXO database is necessary. Once a node has bootstrapped and synced, it need not store the entire blockchain. It can store just the UTXO database (plus a few recent blocks to handle rollbacks), and keep updating this database as new blocks are mined. Thus, even if a node is not storing blocks, it must still parse every new block to update its UTXO database. Also note that a node that does not store the blockchain cannot help other new nodes to bootstrap.


It is helpful to consider each (unused) $ref_i$
%$A_1\sr{ref_1}{\ra}x_1$ 
above as a ``closed box'' with $x_i$ inside, and the act of using $ref_i$ in a transaction as ``opening the box'' and releasing $x_i$. A box can be opened at most once and the act of sending bitcoins to an address ($B_i\la y_i$) generates a new closed box with $y_i$ inside. 

The semantics of transactions are specified using some encoding and a DSL called {\em Script} (a stack-based language similar in design to Forth). 
A node validates transactions as follows.
%As a basic requirement, Script has the following instructions:

% verifying signature
% input script defines the steps to do (i.e., verify signature)
% output script defines how to create the new box

\begin{enumerate}
  \item	For each input $A_i\sr{ref_i}{\ra}x_i$ from $(A_1\sr{ref_1}{\ra}x_1, A_2\sr{ref_2}{\ra}x_2, \ldots, A_n\sr{ref_n}{\ra}x_n)$
	
	\begin{enumerate}
		\item Load signature $\sigma_i$ and public key $A_i$ into stack. 
		\item Using $ref_i$, find box $A_{i}\la x_i$ from the database of unopened boxes. This is the output of a transaction where $A_i$ received $x_i$ bitcoins. 
		\item The loaded box contains the amount to be released as well as ``unlocking instructions'', a sequence of Script operations that verify the above signature on $M$. This is also loaded on the stack and evaluated. The box is opened if the output of the program is True (non-zero).
	\end{enumerate}
	\item If all boxes are opened, then we create new boxes $B_i\la y_i$ as defined by the outputs, provided that the total amount released from boxes is more than or equal to the total amount in the newly created boxes. 
\end{enumerate}

The opened and created boxes are not immediately committed to the UTXO database. Rather, every node must wait for the network to ``confirm'' the changes implied by any given transaction.  
Transactions are confirmed in bulk such that all nodes quickly reach a consensus on which set of transactions to include in the next database update. 
To ensure consistency and fast consensus, not everyone gets to choose which transactions to commit but only those nodes who have a large amount of computing resources (called ``miners'').

 
\section{Confirming Transactions}
\label{sec:verify}
Miners are nodes that propose a set of transactions to commit along with a proof that they have put in a certain minimum amount of work (in the form of CPU cycles) after the last update. The network selects the first solution. 

Roughly, the process of confirming transactions is as follows: 
\begin{enumerate}
	\item A bunch of unconfirmed transactions along with one reward transaction %\footnote{The reward transaction has no inputs. It takes the fees and the block reward.} 
	(known as the \emph{coinbase transaction}) are combined into a `block'.
	\item Hash of the previous block $h_{pr}$ is added to the block. %(version, etc) %. , computed incremented from the last block and the SHA256 hash of the last block is added to the block.
	\item A nonce is added to the block.
	\item Hash%SHA256(SHA256
	($b$) %)
	 of the final block $b$ is computed. 	
\end{enumerate}

If the output of the hash contains at least a specified number of leading zeros, the puzzle is solved, otherwise the miner tries with different nonces until the puzzle is solved or some other miner broadcasts the solution of a puzzle for a block referencing $h_{pr}$. A correct solution implies that the corresponding block is `mined' and all transactions contained in it are confirmed.
%Assuming that $M$ solves the puzzle first, block $b$ is considered `mined' and is broadcast to the network for other clients to append it to their blockchains. After this the transaction is confirmed. 

\paragraph{Confirmations:} The number of confirmations of a transaction are the number of blocks in the blockchain that have been accepted by the network since the block that includes the transaction. The possibility of double-spending a transaction decreases exponentially with the number of confirmations. The default client requires 6 confirmations for normal transactions and 100 confirmations for reward transactions before they can be spent.  

\paragraph{Transaction pool management:} Each client maintains a pool of unverified (but valid) transactions. An element is removed from this pool when that transaction gets included in a mined block. This ensures that even if a transaction is not included in an immediate block, it is kept in the pool until it gets mined. If a transaction is not confirmed within 72 hours then it forgotten. 

\section{Block Structure} 

A block consists of a variable-size {\em payload} containing the actual transactions in a Merkle tree structure and a fixed-size {\em header} describing the payload. The header is 80 bytes and contains: 
\begin{enumerate}
	\item The root hash of the Merkle tree of transactions.
	\item The current block index and the previous block-header hash.
	\item The nonce, the corresponding difficulty target and a timestamp.
\end{enumerate}

Earlier we stated (for simplicity) that the PoW is computed as a hash of the entire block. However, this is not true. The PoW is computed only on the header and not the payload. This enables nodes to verify PoW using just header information, while the payload can be verified later via the root hash. 

\paragraph{Example of header:} The following is an example of a block header\footnote{https://bitcoin.org/en/developer-reference\#block-headers}:\\
\texttt{\underline{02000000}b6ff0b1b1680a2862a30ca44d346d9e8910d334beb48ca0c00000000}\\
\texttt{00000000\underline{9d10aa52ee949386ca9385695f04ede270dda20810decd12bc9b048a}}\\
\texttt{\underline{aab31471}24d95a54\underline{30c31b18}fe9f0864}

The different sections are identified by alternating underlines:
\begin{enumerate}
	\item Block version: \texttt{02000000} (decodes to 2).
	\item Hash of previous block's header: \texttt{b6ff0b1 $\ldots$ 48ca0c0000000000000000}.
	\item Merkle root hash of payload: \texttt{9d10aa52 $\ldots$    decd12bc9b048aaab31471}.
	\item Unix timestamp: \texttt{24d95a54} (decodes to 1415239972).
	\item Difficulty target: \texttt{30c31b18} (decodes to $1bc330_{\texttt{hex}} \cdot 256^{18_{\texttt{hex}}-3}$).
	\item Nonce: \texttt{fe9f0864}.
\end{enumerate}
	
\paragraph{Computing the Merkle root:} Merkle tree is a technique for authenticating small slices (few transactions) from a large chunk of data (entire payload) without having to authenticate the entire data (however, the entire data can be authenticated if needed). The transactions are first arranged in some order that satisfies the consensus rules given below. Their transaction hashes (TXIDs) are considered as the last row (leaves) of the tree that will be constructed. Starting with the last row, each row is iteratively processed to get the previous (parent) row until the currently processing row has only one node, the Merkle root. 
If the currently processing row has two or more nodes, we first ensure that there are even number (say $n$) of them, by repeating the last node if necessary. Then we pair the nodes to form $n/2$ pairs. Each pair $(L, R)$ is concatenated and its hash $\texttt{SHA256}(\texttt{SHA256}(L||R))$ forms the parent for the next iteration. This process is repeated until the root is reached. 

\paragraph{Consensus rules:} A client rejects block that do not follow the below rules:
\begin{enumerate}
	\item The coinbase transaction's TXID is always placed first.
	\item Any input within this block can spend an output which also appears in this block (assuming the spend is otherwise valid). However, the TXID corresponding to the output must be placed at some point before the TXID corresponding to the input. This ensures that any program parsing block chain transactions linearly will encounter each output before it is used as an input.
\item If a block only has a coinbase transaction, the coinbase TXID is used as the merkle root hash.
\end{enumerate}

\paragraph{Payload:} The first field of the payload defines the number of transactions. The rest of the payload contains the raw transactions concatenated in the same orders as in the Merkle tree.



\section{Security and Privacy} 

At the heart of Bitcoin is the concept of the blockchain, a distributed global ledger of transactions that each node holds. The goal of the protcol is to ensure {\em eventual consistency}; if the network is completely synchronized then all nodes will have an identical copy of the blockchain. Thus, the primary goal of Bitcoin is to select the ``valid'' chain given more than one contenders. 


\paragraph{Selecting a unique chain:} It is conceivable that an attacker (or network failure) can cause two or more competing chains to be temporarily (a {\em soft-fork}) or permanently (a {\em hard-fork}) present in the system. The nodes should be able to quickly reject the ``invalid'' one. The protocol selects the chain with the highest cumulative difficulty, rather then the longest one. 

\paragraph{Difficulty level adjustment:} Difficulty is a measure of the hardness of the puzzle and can be quantified by $x$, the maximum possible number representable with that many leading zeros. 
A difficulty level of $d$ implies that $d = 2^{256}/x$. Thus, the smaller $x$ is, the larger the difficulty. The difficulty is adjusted every 2016 blocks based on the time it took to find the previous 2016 blocks. At the desired rate of one block each 10 minutes, 2016 blocks would take exactly two weeks to find. If the previous 2016 blocks took more than two weeks to find, the difficulty is reduced. If they took less than two weeks, the difficulty is increased. The change in difficulty is in proportion to the amount of time over or under two weeks the previous 2016 blocks took to find.

\paragraph{Storage Requirements:} As discussed earlier, at the minimum each node must store the unopened boxes in a UTXO database to ensure that the spender actually holds those bitcoins. Additionally, each node may store the entire blockchain starting from the genesis block to help other clients to bootstrap. 

\paragraph{What can be pruned?} If all the closed boxes generated in a particular block have been opened, that block is not needed for validation (we need blocks to validate/proof that our UTXO database is valid). Thus we can only store the headers for those blocks.\footnote{However, in the existing protocol, we cannot prove to another node that all generated boxes in a pruned block have been used up. A proposal of {\em block-level aggregation} of transactions could allow that.}



\paragraph{Security Requirements:} For security, we require the following: (1) The inability of an attacker to send bitcoins from addresses whose private key is not known, (2) The inability of an attacker to double-spend bitcoins or reverse a transaction, and (3) The inability of an attacker to prevent some valid transactions from confirming. The first requirement is satisfied if the underlying signature scheme is existentially unforgeable. The second and third requirements, formalized respectively as {\em persistence} and {\em liveness} in~\cite{Garay2015}, can be achieved if the underlying proof-of-work (PoW) based consensus system satisfies the following two properties~\cite{Garay2015}:
\begin{enumerate}
	\item {\em Common prefix:} If all honest participants remove the top (newer) $k$ blocks from their chains for a large enough $k$ then all of them will share a common prefix. In other words, the chains held by honest miners will either be identical or be contained in the others.
	\item {\em Chain quality:} There is some minimal integer $\lambda\geq 1$ such that, if the combined computing power of honest parties is $\lambda$ times that of the adversary, then a non-negligible amount of blocks generated by honest parties will make it into the chain. 
\end{enumerate}

If the difficulty level is sufficiently high and the network synchronization time (time between a new block being injected and reaching all participants) is short compared to average block generation period (10 minutes in Bitcoin) then the protocol offers high security. On the other hand, security is weakened if any of the following conditions hold~\cite{Garay2015}:
(1) overall computing power is low, (2) blocks are generated too fast, or (3) network takes long time to synchronize. 

\paragraph{Attacks on Implementation:} Following are attacks specific to Bitcoin:
\begin{enumerate}
	\item {\em Reused R-values:} The underlying signatures ECDSA can be broken if the same randomness is used in two different signatures~\cite{reusedRvalues}. Thus, implementations must take additional care to use true randomness or message-specific one (computed as a hash of the message).
	%\item {\em Attack on cumulative difficulty:} Since the initial difficulty is small in the first two years of Bitcoin, a powerful attacker may be able to forge a chain longer than the current one  with higher cumulative difficulty. This attack becomes more difficult as the cumulative difficulty increases.
	\item {\em Centralization of mining:} If a majority of the mining power is concentrated in a few pools, then they can collude and attack bitcoin. Part of the reason for this threat is the susceptibility to ASIC mining~\cite{asic}.
	\item {\em Denial of service attacks:} Certain attacks are based on miners forcing other miners to skip block validation by generating large blocks or ones that require expensive verification. Thus, they could send wrong data that will result in other miners to later lose their work.
	\item {\em Malleability:} The signature encoding in Bitcoin is such that if a certain bits of the signature are toggled, the result is still a valid signature (this is due to the underlying ECDSA scheme). This allows miners to mine a transaction whose is different from the original, while keeping everything else (i.e., inputs/outputs) same. If a bitcoin service uses the transaction hash to monitor sent funds, then it could lose funds~\cite{gox}.
\end{enumerate}

\paragraph{Privacy:} The addresses serve as pseudonyms and provide some anonymity. However, bitcoin does not provide true anonymity because the inputs are linked to the previous outputs via a reference.


\chapter{A Blockchain System Design}             % chapter 2
\section{Introduction}     


Consider Bitcoin as an example. Peers are holding money in form of algorithmically issued tokens. They do not trust each other, and do not to seek for a trusted mediator. Instead, they are running a Bitcoin protocol which builds a blockchain, a type of {\em append-only database} (or log). Older data in the blockchain can be considered {\em tamper-resistant} because it is protected using a consensus build using {\em proof-of-work} (a solution to a exponentially hard puzzle that can be verified efficiently, once known). The design of the protocol is such that the puzzle becomes harder as the data gets older. However, freshly added data (i.e., the last few versions of the log) are considered potentially unstable. Double spends are prevented using this database because the entire transfer history of any satoshi can be traced back to the time it was created. Thus, for example, if Alice had sent all her satoshis to Bob, she can't send anything after that and before receiving them from other party.

Using the above idea, we can define a blockchain as a {\em prefix-immutable append log of non-conflicting authenticated events in a decentralized peer-to-peer network}. Let us now elaborate on what this means.

Simply said, there are peers do not trust each other. There is no any trusted party, only a protocol peers need to follow~(being effectively thrown away from the network otherwise). Peers are issuing authenticated~(signed) events of some semantics. For example, they are sending out signed payments. Or they are registering \(name \rightarrow value\) correspondences in a shared database~(certificates, domains). ``Prefix-immutable append log'' means all the peers following the protocol are agree on immutable prefix of events append log. That is, if we cut a suffix of some length from the log a peer holds, for each peer, same-size prefixes will be the same, with overwhelming probability. Events in the ordered prefix-immutable log must be non-conflicting in order to have flawless history.

Consider Bitcoin as an example. Peers are holding money in form of algorithmically issued tokens. They do not trust each other, and do not to seek for a trusted mediator. Instead, they are running a Bitcoin protocol which builds prefix-immutable append log containing token transfers. Last few versions of the log are considered potentially unstable, but before them the history is considered as irreversible. The payments history is flawless, so, for example, if Alice had sent all her tokens to Bob, she can't send anything after that and before receiving tokens from other party.

\subsection{Security of Bitcoin}

Like any multiparty protocol, Bitcoin needs {\em correctness} (`valid transactions' should go through) and {\em soundness} (`invalid transactions' must be blocked). Correctness is defined in terms of passive adversaries, who behave according to protocol and do not attempt deviate. 

%We will discuss how correctness 
%Correctness is trivially guaranteed because if all parties behave correctly, then the protocol indeed behaves as expected [...]. For soundness
\section{Cryptography}

At the minimum, Bitcoin requires the following cryptographic primitives:
\begin{enumerate}
	\item One-way hash functions: A one-way function is easy to compute in the forward direction but difficult to reverse. A hash function maps arbitrary sized strings to fixed size ones. We require the hash to be {\em collision resistance} (hard to find two arbitrary preimages with same hash) and {\em preimage resistance} (given hash, find any preimage). A good hash function can be modeled using a {\em random oracle}, where there is no better way to break it than by brute force. By breaking, we imply finding a preimage satisfying certain predicate on the output. 
	\item Signature scheme: A signature scheme is a type of public-key cryptography (i.e. based on two keys), where a private key is used to generate a {\em signature} on a message and the public key is used to verify the signature. Only knowledge of private key and the message allows creating a valid signature. The owner of a public key also cannot later deny having created the signature. 
	We require that the attacker cannot generate valid signatures on any arbitrary message even using the signing oracle on any other arbitrary messages. This is called UF-CMA (unforgeability under adaptive chosen message attack).
	
	We actually require a stronger property called {\em strong unforgeability} (SUF-CMA). This requires that an attacker having access to the signing oracle for arbitrary messages cannot generate a {\em new} signature on a message whose signature has already been queried. Unfortunately, the signatures used in Bitcoin do not satisfy SUF-CMA (they do satisfy UF-CMA though). This has led to the {\em malleability} problem in Bitcoin.
	
\end{enumerate}



\section{Transactional Layer}

In this section we define a generalized view of transactional semantics of a blockchain system. The two foundational concepts here is a \textit{state} and a \textit{transaction}.

\subsection{Minimal State}     % section 1.1
	Consider a transaction arrived at a node. The node is doing following on receiving it:

    \begin{enumerate}
		\item Checks whether a transaction is valid
		\item Apply it if so
    \end{enumerate}

	Intuitively, there are some stateless checks, e.g. whether a signature for a transaction is valid, whether amount of tokens to transfer is non-negative, but also there are stateful ones. For example, if Alice is sending tokens to Bob, a node must be sure Alice has enough funds in order to make a payment. Or, if Alice is registering a domain, a node must be sure it is not taken yet. 

	So a node needs to store some state in order to validate incoming transactions. And there is some \textit{minimal state} representation enough to validate an arbitrary transaction while removing any element from the representation eliminating this property. So all the nodes share this minimal state but a node could also store some additional information. 

	By applying a transaction a minimal state is being modified. It should be impossible to apply a transaction already processed. 

	For many reasons almost all cryptocurrencies of today are packing transactions into \textit{blocks}. We can think about a block as of \textit{atomic batch state update}. 

    [TODO: Block header - tx part]


	We can state some axioms here.

	\begin{axiom}
	 There is some initial state hard-coded into each node. Further we name it \textit{genesis state}.
	\end{axiom}

    \begin{axiom} 
     Validation and application of a transactions(and possibly an additional metadata) are deterministic procedures. All the honest nodes follow the same rules. 
    \end{axiom}

	\begin{proposition} If the same sequence of blocks is applied to the genesis state for two different nodes, then the resulting minimal states will be the same.
	\end{proposition}	
	\begin{proof}Consider the nodes have the same minimal state and trying to apply the same block to it. By the Axiom 2, they will have the same minimal state as result, as verification and application procedures are deterministic. By the Axiom 1, genesis state is the same for all the nodes. By induction, result of sequential applying of the blocks results in the same minimal states for all the nodes.\end{proof}

Further we will use both the terms ``minimal state'' and ``state'' interchangeably. 


\subsection{Bitcoin}

In Bitcoin a transaction contains multiple \textit{inputs} and \textit{outputs}. Inputs are connected with outputs of transactions previously applied to a state, and the connected outputs must not be spent yet. That is, the outputs to be connected by the inputs of the transactions do not have connections from transactions previously applied to the state. Thus an output could be spent as whole only and so we can consider a set of unspent outputs as a minimal state.

How to spend an output? In Bitcoin it contains a script in a stack-based language. Input also contains a script. Then an input could spend an output if a combined script made of inputs' and then outputs' could be executed and results in non-zero top stack item.

[TODO: example]

\subsection{Boxes, Propositions and Proofs}

Abstracting the Bitcoin-like model, a minimal state could be represented as a set of \textit{closed boxes} of size \(n_S\). Each box has a value associated with it. Say, a transaction opens \(n_k\) boxes and also creates \(n_b\) new closed boxes, then the resulting state set has the size of \(n_S-n_k+n_b\) after applying the transaction to it. 

How to open a box? We can protect a box with a script in Bitcoin language. Or we can put a public key into closed box and then it is possible to open it with a proof of private key knowledge, a signature~(we will consider details further). To describe these approaches as well as many others possible in a general way, we say a box is protected by a \textit{proposition} of some kind, and in order to open it, a \textit{proof} of the same kind must be provided. There are some tricky details we will discuss further.

A box can has some additional to a value data inside. For example, it can contain a domain record or a certificate. Anyway, box contents matters for every full node until it is closed. 

\subsection{Namecoin}

Namecoin is a descendant of Bitcoin which in addition to token transfers, introduce \textit{name} $\rightarrow$ \textit{value} storage. In general, values could be arbitrary, but there are few  standard namespaces with predefined semantics, for domains and identities.

We do not specify Namecoin design precisely below, but some Namecoin-like design. 

Consider a transaction contains a box with \textit{name\_register} command specifying a \textit{name} $\rightarrow$ \textit{value} correspondence. Such a box has zero value and associated with a public key \(pk\). It is demanded to pay some fee in order to put such a box into state. The box lives in the state for some period of time, then it is considered as expired and could be thrown away from a minimal state. It is possible to renew or transfer ownership to a different public key by publishing a \textit{name\_update} box replacing an original one in the state.

This design has a critical flow. A block generator could refuse to include \textit{name\_register} command into a block and put its own value for the same name. This is an example of \textit{frontrunning attack}, when an original transaction is suppressed by another one issued by an attacker. In order to avoid frontrunning attacks, Namecoin has \textit{name\_new} command to announce the intention to register a name by providing its hash value.


\subsection{Nxt and Ethereum}	

Having a Bitcoin wallet, you can be goggled by complexity of boxes and propositions in form of stack-based scripts. Why not to have just accounts and token transfers between them instead? 

Actually some of Bitcoin successors walked this path. For example, Nxt has a dedicated notion of accounts. An account is associated with its public key. A transaction transfers tokens from one account to another and needed to be signed by the sender. For such a system stateful verification needs for a minimal state in form of table holding a correspondence between accounts and their balances.

With such a simple minimal state design we have a problem though. Let's describe it with an example. Alice has 50 tokens at some moment of time. She issues a signed transaction to pay 5 tokens to Bob. A node can validate the transaction and found it valid, and so applicable. After the application Alice has 45 tokens. But how to prevent second application of the transaction? Our minimal state representation seems to be flawed.

Ethereum solves the problem by modifying minimal state representation adding ``nonce'' value to it. That is, minimal state is not about (public key $\rightarrow$ balance) correspondence anymore, but (public key $\rightarrow$ (nonce, balance)). Transaction contains nonce value \(txnonce\) as well, and transaction is valid and so applicable only if \(txnonce = nonce + 1\). By application, \(nonce := txnonce\). 

Unlike Bitcoin, Ethereum sets strict order of transactions issued by an account. In Bitcoin, transactions could be applied in any order, 
if they are spending non-overlapping sets of outputs, and input of one transaction does not spend an output of another. In Ethereum, order of transaction is set by nonce values. 



\subsection{Transactional Metadata}

Assume we have a set of objects serializable to a set of unique byte arrays. We want to \textit{authenticate} these binary representations in an efficient. That is, we want to calculate a fixed-sized value for a whole set such as a single bit change always results in a change of the \textit{authenticating}~(or \textit{root}) value, and the value is collision-resistant, so it is impossible(with non-negligible probability) to generate different set resulting in the same root value. 

[TODO: Merkle tree / authenticated data structures explanation]

Along with transactions, we can put some aggregated data about them. For example. in Bitcoin's block a root hash of a Merkle tree for the transactions in block is put into the block. That way it is possible for nodes in a network to exchange not full blocks but \textit{blockheaders}. A \textit{blockheader} is a block without its transactions. By including transactions root hash into the blockheader it is possible to have it spread around a network and be sure it is impossible to show transactions set other that was included. 

[TODO: Bitcoin example]

\subsection{Transactional Layer Generalization}

After the examples, let's summarize what we have in common in all the observable cryptocurrencies.

\begin{enumerate}
\item{\textbf{A Proposition And A Proof.}}
In an every imaginable blockchain we have objects to be protected by secret owners. To achieve the property of being protected we introduce a proposition, and an object could be modified or destroyed only by presenting a proof satisfying a proposition. There are a lot of possible instantiations, e.g. Bitcoin scripts or digital signatures. 
\item{\textbf{Box Structure.}}
There is a minimal element of a replicated state we are calling a \textit{box}. A box is protected by a proposition. It is possible to modify it or destroy it only by showing a proof satisfying a proposition. 
\item{\textbf{Minimal State.}}
Minimal state is a most compact structure giving an ability to verify a transaction against it. Minimal state is about a set of boxes. 
\item{\textbf{Transaction And Transactional Language.}}
Transaction is a smallest possible atomic state modifier. A transaction is to be verified against a state in a deterministic fashion~(so given a state and a transaction, two nodes will always give the same validation result whether \textit{true} or \textit{false}). If a transaction is valid against a state it could modify the state. Validation and application rules are individual~(Ethereum even brings quasi Turing completeness here).
\item{\textbf{Block.}}
All the blockchain systems are storing transactions in full blocks. Most of them also have some authenticating value for the set of block transactions included into block thus it is possible to use block headers instead of full blocks in many scenarios in order to reduce a load.
\end{enumerate}


[TODO: wallet section?]

\section{Consensus}

We have proven(in the proposition~[?]) that if the same sequence of blocks carrying transactions is applied to the same genesis state for two node then they will have the same state. It is exactly what do we want to achieve, but how to have the same sequence of blocks for all the nodes? 

In the first place, we can achieve this only for nodes willing to achieve this by following some protocol strictly. We refer to such nodes as to \textit{honest} nodes, and to the protocol as to \textit{consensus protocol}. If nodes are not following the protocol we call them \textit{byzantine} nodes. A byzantine node could be malicious, but also it could be not able to follow the consensus protocol because of software bugs, problems with connectivity, misleading information sent from outer world etc. 

[validity, agreement, termination]

Computer Science studies consensus protocols since early 1980s. A lot of interesting results were generated in this field. For example, it is impossible to achieve consensus using a deterministic procedure for a set of nodes if they are exchanging messages asynchronously and a single process could fail(Fischer-Lynch-Paterson theorem~\cite{fischer1985impossibility}). 

Consensus in open networks, so with unknown number of participants, is pretty new and very hard question. 

\begin{enumerate}
\item{Validity}
\item{Agreement}
\item{Termination}
\end{enumerate}

For a blockchain consensus protocols, we can state following properties:

\begin{enumerate}
\item{Consistency(or Prefix immutability)} - for two honest nodes the probability to have different prefixes after cutting last \(k\) blocks should go down with \(k\) and be negligible after some value. The good option is to have the probability going down exponentially with \(k\).
\item{Chain Quality} - a party having \(x\%\) of voting power should produce no more than \((\alpha \cdot) x \%\) blocks in a long run, where \(\alpha\) is constant.
\item{Chain Growth} - over time blockchain should always grow. No one is interested in a structure with possibility to stuck. 
\end{enumerate}


\subsection{Proof-of-Work}

Proof-of-Work consensus protocol introduced in the foundational paper of Bitcoin~\cite{Nakamoto2008} is in the core of Bitcoin, Ethereum as well as many other cryptocurrencies. The basic idea of the protocol is to force miners to iterate over output of some function with a small probability of success per iteration. A successful result is giving a right to generate a block. The probability is adjusted automatically via \textit{difficulty} parameter \(D\). 

In case of Bitcoin, the function is just a hash function, but what is about its input? 

We want to make blocks immutable after creation. For that, we are applying hash function for all the block contents. 

[TODO: Merkle tree]

We also want for a block to refer to a previous block. So we include a hash of a previous block, in this case it in order to replace a block with another one it is needed to replace all its descendants also. As some amount of work is needed to generate each block in order to replace a chain suffix of length \(l\), amount of work proportional to \(l\) is needed.

With Proof-of-Work it is impossible to make a false claim on successful block generation. Such a claim is easily verifiable, as calling hash function is very cheap. Thus a Proof-of-Work works as a protection against Sybil attacks~\cite{}.

\subsection{Proof-of-Stake}

There are some disadvantages of Proof-of-Work schemes. A lot of resources to be spent. During early days a Proof-of-Work currency could be destroyed by a miner already having a lot of computational resources working for another blockchain. 

Can we have a protection against Sybil attacks without spending computational resources? The simplest way to achieve this is to use cryptocurrency tokens as anti-Sybil tools. That is, a probability to generate a block is proportional to a stake a node holds. 



\subsection{History}

Previously we talked about a blockchain. But in all the global networks collisions are possible~(to prevent them we need to have a global lock or synchronous rounds and then some kind of leader election). So in a network a \text{blocktree} lives.

[TODO: a blocktree picture]

In most cases the fact of blocktree existence in omitted. A node is storing a blockchain. A blockchain has some score(e.g. a chain length, but this is a totally insecure scoring function, see~\cite{stackexchange} for details). If better chain is declared in network, a node is throwing away blocks until common block and then apply better suffix. In this case a node sees a blocktree only during switching from one branch of it to another. There are some proposals to explicitly use a blocktree. For example, in GHOST scoring function~\cite{sompolinsky2015secure} a chain with heaviest tree wins. 


\subsection{Consensus Layer Generalization}

\subsection{Full Node View}
\label{fullnodeview}

Full node is a node which holds at least some state enough to check whether an arbitrary transaction is valid against it and so applicable to it or not. We have defined such a state, \textit{minimal state}, above. Nodes are also storing a history from which the minimal state has been rendered. In addition to the state modifiers log and the minimal state, a fullnode also contains two more entities. \textit{Memory pool} contains transactions not yet included into blocks~(and there is no guarantee of inclusion for them). \textit{Vault} contains some node-specific information a node is extracting from the log. For example, it could contain values encoded in some or all OP\_RETURN instructions, or all the transactions for specific addresses. The well-known example of vault is \textit{wallet} which contains private keys as well as transaction associated with their public images.

With the four entities being defined we can explicitly state a node view type now: \(node\_view = \langle history, minimal\_state, vault, memory\_pool \rangle \).

The quadruple could be modified by applying whether an offchain transaction or a block coming from a local side(user issuing a transaction to a local node, mining software generating a block) or from remote peer. We can state some rules of the node view  modification even for the most abstract definition given:

\begin{itemize}
\item an offchain transaction modifies vault and memory pool. Atomicity in this update is not critical.

\item for a persistent node view modifier atomicity for an update is strictly needed! If history is producing rollback sude-effect, other parts must handle it properly before applying an update. This sounds trivial, but in fact many implementation are spending years fighting with bugs related to inconsistency and read-when-update issues.
\end{itemize}


[TODO: pseudocode? or Scala code in Scorex counter-part?]


\section{Peer-to-Peer Network}	

Blockchain is maintained in a peer-to-peer network. For simplicity we are starting with a network where all the nodes [...]

\section{Incentives}



\section{Complications And Alternative designs}

In additions to the systems described in this chapter as well as many other systems used around, there are many designs existing only on paper. In this section we quickly observe some proposals. The goal of Scorex is to help to get them from papers to prototype implementations. 


The various alternative designs are proposed to address some of the problems with Bitcoin explained below:
\begin{enumerate}
	\item Storage scalability: In Bitcoin, every node must store the entire blockchain (currently over 10 GB). This is a bottleneck as the blockchain becomes older. Proposals have been presented that allow pruning of the blockchain under certain assumptions. 
	\item Memory usage: The UTXO set is something that needs to be kept in memory for fast validation. This set is currently several hundred MBs.
	\item Rational behavior: If nodes behave rationally, they will not store the blockchain. Rather they will store only the UTXOs they are interested in. In the long run, this could lead to {\em tragedy of the commons}, where no one has a complete copy of the blockchain.
	\item Privacy: While Bitcoin uses pseudo-random looking addresses for privacy, some information is inherently leaked. For instance, we can know all the addresses that a given satoshi has traveled to since its creating. Additionally, we can often infer that certain addresses belong to the same entity.
	\item Delay in confirmations: Bitcoin has an average confirmation time of 10 minutes. However, if the size of the unconfirmed transactions is higher than the maximum network throughput (1 MB/10 minutes), then a transaction can remain unconfirmed for tens of hours. Additionally, since PoW is a randomized process, there is no guarantee that a block will be mined soon, even if the transaction fee is very high.
	\item Transaction throughput: As mentioned in the previous point, the maximum block size is 1 MB. This roughly translates to about an average of 144 MB of data added to the blockchain per day if all blocks are full. Assuming a transaction size of the about 224 bytes (the minimum), we get a maximum of 28086 transactions/hour, which may become a bottleneck. %far less than centralized payment systems such as VISA.
	\item Validation-less Mining: Due to latency in network and the large size of blocks, many miners and mining pools do not validate headers. In other words, they start finding the solution using the Merkle root of transaction hashes without validating the batch of transaction themselves (which could be around 1 MB currently). Often this results in a split, where some clients create a Merkle root incorrectly (either deliberately or by accident) such as the softfork due to BIP66 in July 2015\footnote{https://en.bitcoin.it/wiki/Softfork\#2015\_BIP66\_Blockchain\_Fork}, where certain miners were creating invalid blocks and others were building a chain on top of those.
	\item Fully prunable outputs: In Bitcoin, certain outputs cannot be provably spent (such as those with value 0 -- those created using OP\_RETURN\footnote{https://en.bitcoin.it/wiki/OP\_RETURN}) or sent to an output that cannot be provably spent\footnote{Example: https://blockchain.info/address/1CounterpartyXXXXXXXXXXXXXXXUWLpVr}. Such unspent outputs serve no meaningful purpose to Bitcoin nodes and can be prunes from their UTXO set. 
\end{enumerate}


%[TODO: ZCash]

%[TODO: fully prunable outputs]

\subsection{SPV}

SPV (Simple Payment Verification) is an alternative to Satoshi's Bitcoin protocol and operates on top of the same blockchain. It is designed to enable lightweight clients that can sync in minutes instead of days and store only a fraction of the information (few MBs) compared to a full node (several GBs). 
In this method, a node only verifies headers from the genesis block and validates only the last few full blocks (enough for rollback). The key idea in SPV is that the security of PoWs is not measured by block height (the number of blocks since the genesis block) but rather the depth (the number of blocks mined since a particular payment has been confirmed). This allows clients be able to verify payments quickly. However, the security of SPV has not been formally proven.

Implementations of SPV nodes use a protocol extension called {\em bloom filters}, described in BIP 37. They use headers for blocks prior to their wallet's birth timestamp, and request filtered blocks for the rest by sending a bloom filter to its peers. The peers then send the relevant transactions for blocks along with the Merkle paths.\footnote{http://bitcoin.stackexchange.com/a/11721/2075}

\subsection{Rollerchain}

Rollerchain (RC) is a proposal aimed to (1) reduce storage and (2) enforce nodes to store blocks and prevent tragedy of the commons. RC stores data only for verifying recent $k$ iterations for some security parameter $k$. This is similar to SPV mode, where the nodes additionally store the last $k$ blocks. However, rational nodes in RC are {\em enforced} to store the entire sequence of blocks for a certain depth $\leq k$ determined solely from the public key. To create a successful PoW, nodes must additionally prove storage of one or more snapshots determined via a hash of their public key and the current block index. Since the index changes with each block, there is a {\em sliding window} of snapshots from which a node must store a few. The index of stored snapshots also slides with the window and nodes must recompute this at every new block. Consequently, nodes are implicitly forced to store all the blocks till the depth of their earliest snapshot. 
In RC, the block header contains a Merkle root hash of the minimal state that will be obtained after the block is applied. Additionally, the Merkle root hash of the transactions and a Proof of Storage of snapshots is also present in the header. 

[Not very clear how the Proof of storage works -- Alex, please add some text?]


\subsection{GHOST}

The GHOST protocol is designed for blockchains with very fast block times. As the network becomes less synchronized and blocks are generated fast, a significant amount of PoW will not make it into the main chain due to orphans. This leads to reduced security. The GHOST proposal makes use of the additional orphaned blocks to strengthen the network instead of rejecting them. Thus, two different branches will be compared not just by length but how `heavy' they are in terms of PoW. A GHOST protocol has various mechanisms for rewarding orphans. Etherium is one example that follows the GHOST strategy.

\subsection{Bitcoin-NG}

Bitcoin-NG (or simply NG) was proposed to solve two main issues in Bitcoin: 
\begin{enumerate}
	\item {\em Reduce confirmation time:} Current Bitcoin transactions require an average of 10 minutes for the first confirmation. In NG, the first confirmation is very fast (within 30 seconds; roughly the time to cross the network). 
	\item {\em Increase transaction processing bandwidth:} Furthermore, much more transactions can be inserted into the blockchain between two successive PoWs. This is only limited by bandwidth and processing constraints of miners.
\end{enumerate}

While Bitcoin is retrospective based (i.e., the PoW captures transactions created {\em before} the PoW was formed), NG is forward-looking in that the PoW enables a miner (aka {\em leader} in NG) to confirm transactions in the future. 

The main idea in NG is to remove the link between transaction confirmations and the {\em leader selection}. A leader is essentially someone who's PoW is accepted. In NG, the leader is still selected based on PoW but the block selecting the leader (the {\em key-block}) does not contain transactions. Rather the currently selected leader (i.e., the public key) has the sole power to decide the transactions for the blockchain in several {\em micro-blocks} until the next leader is selected. The leader adds the transaction without much delay, ensuring that transactions get confirmed (with one PoW) very quickly. Furthermore, there is no limit to the number of micro-blocks that can be inserted, ensuring that the throughput of the network is high.
We summarize the main features of NG:
\begin{enumerate}
	\item Two types of blocks: {\em key blocks} that contain the PoW, a reference to the previous block and a coinbase (reward) transaction but no other transactions. The key block additionally gives the miner the ability to create several {\em micro-blocks} containing one or more transactions until the next PoW (i.e., key-block is found). Miners only compete for key-blocks.
	\item The fees is split into a 40-60 ratio, where 40\% goes to the owner of the current PoW and the rest to the next PoW.
\end{enumerate}

\subsection{ByzCoin}

ByzCoin builds on the ideas of NG of separating the confirmations and leader selection. There are several differences from NG discussed below:
\begin{enumerate}
	\item Two separate blockchains: The key blocks and micro-blocks are part of two different chains. A key-block links to the previous key-block (the {\em main chain}) and the micro-blocks form a {\em secondary chain} and also link to the corresponding key-block in the main chain. 
	\item Different process for mining micro-blocks: While key-blocks are mined in a similar fashion to NG, the micro-blocks are mined using a the Practical Byzantine Fault Tolerant (PBFT) protocol~\cite{pbft} run by the leader. The group of members who participate (the {\em replicas}) are selected from a sliding window of miners who contributed a PoW in the last time-slice (say 24 hours). The amount voting power held by a miner is proportional to the amount of blocks contributed in that window.
	\item Interactive consensus protocol: The replicas perform an interactive protocol using PBFT and combined signatures to obtain consensus on the micro-blocks to insert.
\end{enumerate}

The key difference with NG is that while a transaction is instantly confirmed in NG, it is not permanent in the case of dishonest miners because there is no control over how a miner generates micro-blocks. ByzCoin adds a level of consensus even for micro-blocks so the chance of those rolling back is negligible compared to NG.

\section{ZeroCash}

ZeroCash (ZC) is a blockchain based protocol designed for privacy. Since the data in the Bitcoin blockchain is public, true anonymity is not present. 

\paragraph{ZeroCoin:} ZC can be considered an extension of ZeroCoin (ZCn), an earlier proposal. In order to describe ZC, we will first describe ZCn. 

Assume that all coins to be obfuscated are of a single denomination, say 1 BTC. ZCn has its own currency called Z, such that 1 Z = 1 BTC. There is a pool of obfuscated Z coins called {\em Zero-Pool}. Alice wants to anonymize her Bitcoin represented by serial number $c_A$. In order to do that, she begins by exchanging $c_A$ with an equivalent Z coin as follows. She generates a secret serial number $s_A$ and another secret $r_A$. Then she creates a commitment $z_A$ to $s_A$ using $r_A$ as randomness. That is, $z_A=$ COMM$_{r_A}(s_A)$, which is the Z coin Alice will use in exchange for $c_A$. All such exchanged coins are automatically added to the Zero-Pool. The commitment has a computationally binding and perfectly hiding property so no knowledge of $s_A$ or $r_A$ is leaked from $z_A$. Later on Alice will take back her $z_A$ using a transaction $t_A$, which is then automatically converted to 1 BTC. For anonymity, an adversary should not be able to link $t_A$ to $z_A$. This is achieved using Non-interactive Zero-Knowledge Proofs (NIZKs).\footnote{A NIZK proof is understood as follows. Let $N$ be an instance of a hard problem, such as finding the factors of a large integer. Let $P$ be a witness to this problem that Alice knows. There are three requirements of NIZK proofs: (1) Given a \textbf{random} string $R$, Alice can construct a short proof $\pi=$ PROOF$(P, R)$ such that VERIFY$(\pi, R, N)=true$ iff Alice `really knows $P$'. The concept of `knowing' is captured as follows: (2) If Alice can be fooled into using a \textbf{maliciously crafted $R$}, then $\pi$ will reveal $P$ with a high probability. (3) Additionally, Alice can construct pairs $(\pi', R')$ such that VERIFY$(\pi', R', N) = true$ without knowing any witness $P$ as long as \textbf{she selects $R'$}. Thus, the generation of $R$ is of outmost importance because if the verifier selects $R$, the secret is leaked and if the prover selects $R$ then the proof is not convincing. If given the transcript of a proof, we cannot distinguish between the cases (1) and (3), then the protocol is zero knowledge, intuitively because because given some $(\pi, R)$ pair, there is no way of knowing if it was generated using (1) or (3).} 

Alice creates a spend by revealing $s_A$ (but not $r_A$) and creates a NIZK proof of the NP statement ``I know $r$ such that $z=\text{COMM}_r(s_A)$ and $z \in \text{Zero-Pool}$''. The process of creating a commitment and revealing only one input (but never opening them completely) may seem counter-intuitive, but this in fact makes the statement provable by efficient NIZKs, because the circuit for computing the commitment can be efficiently coded into an NP language. The spend could have been done even without revealing $s_A$. However, this is needed for the next property -- security -- so that Alice should not be able to spend $z_A$ twice. This is achieved by keeping track of spent $s_A$s in a public ledger, kept by each client. 

Due to this ZCn has two scalability issues: (1) The Zero-Pool always grows as we cannot determine which of the Z coins have been spent (for anonymity). (2) The spent set always grows as we need to keep track of double spends. Unlike Bitcoin, which uses spends only for bootstrapping and stores only unspent outputs, ZCn must store both the spent and unspent outputs. The unspent outputs is simply the Zero-Pool. 

ZC is an extension of ZCn with the following differences:
\begin{enumerate}
	\item In ZC, the coins are minted in the protocol itself rather than exchanged with Bitcoins. This allows people to transact directly in ZC rather than using it as an add-on to Bitcoin or another currency. In other words, the spent coins also generate Z coins. 
	\item The statement  ``I know $r$ such that $z=\text{COMM}_r(s_A)$ and $z \in \text{Zero-Pool}$'' is replaced by the NP statement  ``I know $r$ such that $z =$ COMM$_r(s_A)$ and $z$ is a leaf node of a Merkle tree with root hash $M$'', where $M$ is the root hash of the Merkle tree of Z coins in the Zero-Pool. This makes the statements much shorter. The value $s_A$ is revealed in order to keep prevent double spends as in ZCn.
	\item ZC allows coins of arbitrary denominations instead of 1 BTC as in ZCn. This is done by introducing a {\em pour} operation that uses a bunch of Z coins and creates new ones without revealing the amount in either the destroyed or created one. The only thing revealed is that the sum of inputs is $\leq$ sum of outputs. This is done by appropriately modifying the Z coins and proving the corresponding NP statement using zkSNARKs. 
	\item ZC uses a variant of NIZKs called zkSNARKS (succinct non-interactive arguments of knowledge). A zkSNARK is essentially a NIZK with the proof and verification-time O(1), and secure against only a computationally bound adversary.
\end{enumerate}

However, 
\section{Conclusion}


\section{Further Reading}

Proof-of-Work and blockchain were introduced in the foundational Bitcoin whitepaper~\cite{Nakamoto2008}.

Overview of Bitcoin P2P layer along with description of possible Eclipse attacks(partly fixed to the moment) against it could be found in~\cite{heilman2015eclipse}



\chapter{Scorex}           % chapter 2
\section{Introduction}     % section 2.1

Scorex is a modular blockchain core framework. It supports definitions given in the previous chapter in form of Scala code. What do you need to do in order to build something on Scorex is to provide implementations for all the abstract interfaces~(possibly reusing code previously written for our projects).

\subsection{Scala Language}         % subsection 2.1.1

We will describe some concepts of Scala language in sections started with ``*''. If you already a Scala developer you can miss the sections. Experience with programming languages~(say, Java, C++, OCaml or Rust) is needed as we will explain Scala features used in code snippets provided very quickly. For a good introduction into the Scala language, please refer to~\cite{odersky2008programming}.

Scala is functional, modular and also object-oriented language. There are several reasons to choose this language:
\begin{enumerate}	
	\item Scala runs on the JVM which allows it to be cross-platform.
	\item Scala inter-operates seamlessly with Java.
	\item Scala is fully functional and consequently allows compact and more readable code.
	\item Scala has powerful constructs for concurrency.	
	\item Scala has powerful type system. Scorex is using typing features of the language extensively.
\end{enumerate}

\subsection{Propositions and Proofs}

In the first place, we are getting into a mechanism to protect binary objects, e.g. transaction outputs, from non-permissioned access. We protect an object with a \textit{proposition}. Then in order to make an action with an object it is needed to provide a \textit{proof} for its proposition. 

Proposition is a very abstract concept. The only property we require from it is to be serialized into bytes. In form of Scala code it is described as:

\begin{lstlisting}
trait Proposition extends BytesSerializable
\end{lstlisting}

In most cases, a proposition claims proof of knowledge of a secret to be provided in a non-interactive zero-knowledge form. For example, in most of popular signature schemes a digital signature is a non-interactive zero-knowledge proof of a private key knowledge. Scorex has a basic entity for that

\begin{lstlisting}
trait ProofOfKnowledgeProposition[S <: Secret] extends Proposition
\end{lstlisting}

A proof is an object which could satisfy a proposition given an additional input, namely a \textit{message}(e.g. transaction bytes). As well as a proposition, a proof could be serialized into bytes. 

\begin{lstlisting}
trait Proof[P <: Proposition] extends BytesSerializable {
  def isValid(proposition: P, message: Array[Byte]): Boolean
  ...
}
\end{lstlisting}

For a \textit{ProofOfKnowledgeProposition} corresponding abstract proof is provided:  

\begin{lstlisting}
trait ProofOfKnowledge[S <: Secret, P <: ProofOfKnowledgeProposition[S]] 
	extends Proof[P]
\end{lstlisting}

\subsection{Box}

A box is a minimal state element. An unspent output in Bitcoin is a box. An account in certain state in Nxt or Ethereum is also a box. Basically, a box is about some amount of tokens associated with it and also some proposition which protects a box from being spent by anyone but a party~(or parties) knowing how to satisfy the proposition.

\begin{lstlisting}
\end{lstlisting}


\subsection{A Transaction and Minimal State}

As it was shown in the Chapter 1[TODO: link], a transaction and a minimal state could be defined via each other: a transaction is a state modifier, which also could be valid or not against a state, and applicable if and only if it is valid. A minimal state is a data structure which deterministically defines whether an arbitrary transaction is valid and so applicable to it or not. 

\begin{lstlisting}
\end{lstlisting}

We are defining functional interface for minimal state below:

\begin{lstlisting}
\end{lstlisting}

So a minimal state knows its current version, can apply a block, and also rollback to a previous version. To validate a transaction, it just calls \textit{validate} function of a transaction and checks its result.

\subsection{Wallet}

[TODO:]

\subsection{Memory Pool}

\begin{lstlisting}


\end{lstlisting}

\subsection{}

\subsection{Node View Holder}


\begin{lstlisting}

\end{lstlisting}

\subsection{Transactional Module}



\section{Consensus Layer}

\subsection{Block}

\begin{lstlisting}

\end{lstlisting}

\subsection{History and Blockchain}

\section{Network Layer}

Network layer in Scorex is simpler than in Bitcoin or Nxt. 

\subsection{Peer Discovery}

\subsection{Broadcasting Strategies}

\subsection{View Synchronizing}

\section{Ready Modules}
There are few modules already implemented.

\subsection{Proof-of-Stake}
Proof-of-Stake module contains implementations of two Proof-of-Stake consensus algorithms. 

\subsection{Simple Transactions Module}

Simplest Transactions Module contains an implementation of transactional module with only one kind of transactions, just tokens transfers from one public key to another.

\subsection{Permacoin Implementation Module}

The module contains an implementation of Permacoin consensus protocol~\cite{miller2014permacoin}.

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{sources}

\end{document}	